{
  // This is a Parsing Expression Grammar (PEG) for a simple calculator.
  // Generate the .go file with '$GOPATH/bin/pigeon $GOPATH/src/calc/calc.peg | $GOPATH/bin/goimports > $GOPATH/src/calc/peg.go'
  // This block is the initializer

  package main

  import (
    "math/big"
    "strings"
  )

	func toIfaceSlice(v interface{}) []interface{} {
		if v == nil {
			return nil
		}
		return v.([]interface{})
	}


	// Evaluate the expression for a rule that consists of an operand, operator, 
	// and expression.
	func handleBinaryOpExpr(num, rest interface{}) (interface{}, error) {
		var err error

		acc := num
		for _, v := range toIfaceSlice(rest) {
			list := toIfaceSlice(v)

			// In the list item 0 is spaces, 1 is op, 2 is spaces, 3 is operand
			o := rune(list[1].([]uint8)[0])
			acc, err = evalBinaryOp(o, acc, list[3])
			if err != nil {
				return acc, err
			}
		}

		return acc, nil
	}	

	// Evaluate the expression for a rule that consists of an operator and operand.
	func handleUnaryOpExpr(op interface{}, num interface{}) (interface{}, error) {
		o := rune(op.([]uint8)[0])

		return evalUnaryOp(o, num)
	}	
}

Input "input" <- n:(Expr / Stmt / Empty) EOF {
  return n, nil
}

// This is just so that spurious carriage returns don't print errors.
Empty "empty line" <- _ {
	return "", nil
}

Expr "expression" <- _ n:(Prec2Expr / FuncCallOrParen) _ {
  return n, nil
}

Prec2Expr "precedence 2 expression" <- num:Prec1Expr rest:(_ Prec2Op _ Prec1Expr)*  {
	return handleBinaryOpExpr(num, rest)
}

Prec1Expr "precedence 1 expression" <- num:Prec0Expr rest:(_ Prec1Op _ Prec0Expr)*  {
	return handleBinaryOpExpr(num, rest)
}

Prec0Expr "precedence 0 expression" <- num:( UnaryExpr / Prec0OpExpr ) {
	return num, nil
}

UnaryExpr <- op:[~-] num:FuncCallOrParen {
	return handleUnaryOpExpr(op, num)
}

Prec0OpExpr "precedence 0 expression" <- num:FuncCallOrParen rest:(_ Prec0Op _ FuncCallOrParen)*  {
	return handleBinaryOpExpr(num, rest)
}

FuncCallOrParen "function call or expression in parenthesis" <- n:(Paren / FuncCall / Number ) {
	return n, nil
}

Paren "parenthesis expression" <- '(' e:Expr ')' {
  return e, nil
}

FuncCall "function call" <- [a-z] [a-z0-9-_]* _ parms:FuncParms {
	return big.NewInt(555), nil
}

FuncParms "function params" <- '(' first:Expr? ')' / '(' first:Expr rest:( ',' Expr )* ')' {
	l := []interface{}{}
	l = append(l, first)

	for i,v := range rest.([]interface{}) {
		// Ignore commas
		if i % 2 == 0 {
			continue
		}	
		l = append(l, v)
	}

	return l, nil
}

Number "number" <- n:(Float / Int) {
  return n, nil
}

Float "float" <- [0-9,]* '.' [0-9]+ {
  f := new(big.Float)
  _, err := fmt.Sscan(strings.Replace(string(c.text),",","",-1), f)
  return f, err
}

Int "int" <- ( ( "0x" [0-9a-zA-Z]+ ) / ( "0b" [01]+ ) / [0-9,]+ ) {
  i := new(big.Int)
  _, err := fmt.Sscan(strings.Replace(string(c.text),",","",-1), i)
  return i, err
}

Prec1Op <- '*' / '/' / '|'
Prec2Op <- '+' / '-' / '&'
Prec0Op <- '^' 

_ "spaces" <- [ \t]*

EOF <- !.

// Statements 
Stmt "statement" <- SetStmt {
	return nil, nil
}

SetStmt "set statement" <- "obase" _ '=' _ v:( "hex" / "dec" / "bin" ) {
	err := outputBase.Set(string(v.([]byte)))
	return nil, err
}

/* vim: set filetype=go :*/
