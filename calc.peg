{
  // This is a Parsing Expression Grammar (PEG) for a simple calculator.
  // Generate the .go file with '$GOPATH/bin/pigeon $GOPATH/src/calc/calc.peg | $GOPATH/bin/goimports > $GOPATH/src/calc/peg.go'
  // This block is the initializer

  package main

  import (
    "math/big"
    "strings"
	  "github.com/jeffwilliams/calc/ast"
  )

	func toIfaceSlice(v interface{}) []interface{} {
		if v == nil {
			return nil
		}
		return v.([]interface{})
	}

	func toStringSlice(v []interface{}) []string {
    r := make([]string, len(v))
		for i,e := range v {
      r[i] = e.(string)
		}
		return r
	}

	func charClassRepetitionToByteSlice(x interface{}) []byte {
    buf := make([]byte,0,100)
    for _,v := range x.([]interface{}){
      buf = append(buf, v.([]byte)...)
	  }
		return buf
	}

	func charClassRepetitionToStr(x interface{}) string {
	  return string(charClassRepetitionToByteSlice(x))
	}

	func buildSlice(first, rest interface{}, ndx int) []interface{} {
    l := []interface{}{}
    if first != nil {
      l = append(l, first)
    }
  
    if rest != nil {
      for _,v := range rest.([]interface{}) {
        // Ignore semicolons
        l = append(l, v.([]interface{})[ndx])
      }
    }
  
    return l
	}

	// Evaluate the expression for a rule that consists of an operand, operator, 
	// and expression.
	func handleBinaryOpExpr(num, rest interface{}) (interface{}, error) {
    if rest == nil {
      return num, nil
    }

    left := num

    for _, v := range toIfaceSlice(rest) {
      list := toIfaceSlice(v)

      // In the list item 0 is spaces, 1 is op, 2 is spaces, 3 is operand
      opStr := string(list[1].([]uint8))
      right := list[3]

      node := &ast.BinaryExpr{Op: opStr, X: left, Y: right}
      ast.SetParent(left, node)
      ast.SetParent(right, node)
      left = node
    }

    return left, nil
	}

	// Evaluate the expression for a rule that consists of an operator and operand.
	func handleUnaryOpExpr(op interface{}, num interface{}) (interface{}, error) {
		o := rune(op.([]uint8)[0])

		return evalUnaryOp(o, num)
	}

	func handleFuncDefOld(parms, help, expr interface{}) (*DefinedFunc, error) {
		buf := charClassRepetitionToByteSlice(expr)
		
		// first try parsing the function's body to see if it's valid.
		// since the body likely contains variables, we'll expect an 
		// unbound variable error but no other ones that indicate
		// a parse error.
		if err := validateFuncDef(parms.([]interface{}), buf); err != nil { 
			return nil, err
		}
		
		var hlp string
		if help != nil {
			hlp = help.([]interface{})[1].(string)
		}
		prm := toStringSlice(parms.([]interface{}))

		// If this function is being defined inside a function being called,
		// save the parameters and local vars from the outer function in the 
		// inner functions scope (bind them). This implements closures.
		var bound map[string]interface{}
		if len(LocalVars) > 0 {
			bound = make(map[string]interface{})
			for i,v := range LocalVars {
				bound[i] = v
			}
		}

		f := &DefinedFunc{ 
			name:       "nameless",
			help:       hlp,
			paramNames: prm,
			body:       buf,
			bound:      bound,
		} 

		return f, nil
	}

	func handleFuncDef(parms, help, expr interface{}) (*ast.FuncDef, error) {
		var hlp string
		if help != nil {
			hlp = help.([]interface{})[1].(string)
		}
		prm := toStringSlice(parms.([]interface{}))

		node := &ast.FuncDef{Args: prm, Help: hlp, Body: expr}
    ast.SetParent(expr, node)
		return node, nil
	}
}

Input "input" <- first:(Block?) rest:((';' Block)*) EOF {
  if rest == nil || len(rest.([]interface{})) == 0 {
    //return first, nil
		stmts := &ast.Stmts{Stmts: []interface{}{first}}
		ast.SetParent(first, stmts)
		return stmts, nil
  } else {
    l := buildSlice(first, rest, 1)
		stmts := &ast.Stmts{Stmts: l}
		for _, v := range l {
			ast.SetParent(v, stmts)
		}
    //return l, nil
		return stmts, nil
  }
}

Block <- n:(Stmt / Expr) {
  return n, nil
}

// This is just so that spurious carriage returns don't print errors.
Empty "empty line" <- _ {
	return "", nil
}

Expr "expression" <- _ n:(Prec3Expr / FuncCallOrParen) _ {
  return n, nil
}

Prec3Expr "precedence 3 expression" <- num:Prec2Expr rest:(_ Prec3Op _ Prec2Expr)*  {
	return handleBinaryOpExpr(num, rest)
}

Prec2Expr "precedence 2 expression" <- num:Prec1Expr rest:(_ Prec2Op _ Prec1Expr)*  {
	return handleBinaryOpExpr(num, rest)
}

Prec1Expr "precedence 1 expression" <- num:Prec0Expr rest:(_ Prec1Op _ Prec0Expr)*  {
	return handleBinaryOpExpr(num, rest)
}


Prec0Expr "precedence 0 expression" <- num:( UnaryExpr / Prec0OpExpr ) {
	return num, nil
}

UnaryExpr <- op:[~-] num:FuncCallOrParen {
	opStr := string(op.([]uint8))
	node := &ast.UnaryExpr{Op: opStr, X: num}
	ast.SetParent(num, node)
	return node, nil
}

Prec0OpExpr "precedence 0 expression" <- num:FuncCallOrParen rest:(_ Prec0Op _ FuncCallOrParen)*  {
	return handleBinaryOpExpr(num, rest)
}

FuncCallOrParen "function call or expression in parenthesis" <- n:(Paren / Lambda / FuncCall / Number / Variable / List / EmptyList) {
	return n, nil
}

Paren "parenthesis expression" <- '(' e:Expr ')' {
  return e, nil
}

FuncCall "function call" <- name:FunctionName _ '(' parms:FuncParms ')' {
/*
	nm := name.(string)
	if parms == nil {
    parms = []interface{}{}
	}
  return Call(nm, parms.([]interface{}))
*/
	exprs := make([]ast.Expr, len(parms.([]interface{})))
	for i,v := range parms.([]interface{}) {
		exprs[i] = v
	}

	node := &ast.FuncCall{Name: name.(string), Args: exprs}
	for _, v := range node.Args {
		ast.SetParent(v, node)
	}
	return node, nil
}

Lambda "lambda" <- "def" _ '(' _ parms:DefStmtParms _ ')' _ help:( '"' DefHelp '"' )? _ '{' _ expr:Expr _ '}' {
	return handleFuncDef(parms, help, expr)
}

FuncParms "function params" <- first:Expr? rest:( ',' Expr )* {
	l := buildSlice(first, rest, 1)
	return l, nil
}

Number "number" <- n:(Float / Int) {
  return n, nil
}

Float "float" <- [0-9]* '.' [0-9]+ {
  f := new(big.Float)
  _, err := fmt.Sscan(strings.Replace(string(c.text),",","",-1), f)
	return &ast.Number{Value: f}, err
  //return f, err
}

Int "int" <- ( ( "0x" [0-9a-zA-Z]+ ) / ( "0b" [01]+ ) / [0-9]+ ) {
  i := new(big.Int)
  _, err := fmt.Sscan(strings.Replace(string(c.text),",","",-1), i)
	return &ast.Number{Value: i}, err
  //return i, err
}

List "list" <- '[' _ first:(Expr)? rest:((_ ',' _ Expr)*) _ ']' {
	l := buildSlice(first, rest, 3)

	node := &ast.List{Elements: []ast.Expr{}}
	for _, v := range l {
		node.Elements = append(node.Elements, ast.Expr(v))
		ast.SetParent(v, node)
	}
	return node, nil

/*
	isInts := true
	for i, v := range l {
    _, isInt := v.(*big.Int)
		_, isFlt := v.(*big.Float)
		if !isInt && !isFlt {
      return nil, fmt.Errorf("lists may only contain ints and floats, but element at index %d is %T", i, v)
		}
 
		if i == 0 {
      isInts = isInt
		} else {
      if isInts && !isInt {
        return nil, fmt.Errorf("lists must contain only ints or only floats; list is ints until element at index %d", i)
			} else if !isInts && isInt {
        return nil, fmt.Errorf("lists must contain only ints or only floats; list is floats until element at index %d", i)
			}
		}
	}

	if isInts {
	  return NewBigIntList(l)
	} else {
	  return NewBigFloatList(l)
	}
*/
}

EmptyList "empty list" <- '[' _ ']' {
	node := &ast.List{Elements: []ast.Expr{}}
	return node, nil
}

//Variable <- id:(Identifier) {
Variable <- id:(Identifier / FunctionName) {
	return &ast.Ident{Name: id.(string)}, nil
	//resolved, err := Resolve(id.(string))
	//return resolved, err
}

Identifier <- [a-zA-Z_] [a-zA-Z0-9_]* {
  return string(c.text), nil
}

// Allow the operators +,-,*,/ to be a function name
// Never allow @ in a function name: it's used internally for naming lambdas.
FunctionName <- ( [a-zA-Z_] [a-zA-Z0-9_]* / "+" / "-" / "*" / "/" / "^" / "&" / "|" / "~" / "]") {
  return string(c.text), nil
}

Prec0Op <- '^' 
Prec1Op <- '*' / '/' / '&'
Prec2Op <- '+' / '-' / '|'
Prec3Op <- ">=" / "<=" / '<' / '>' / '='

_ "spaces" <- [ \t]*

EOF <- !.

// Statements 
Stmt "statement" <- _ s:(SetSettingStmt / SetStmt / DefStmt / HelpStmt) _ {
	return s, nil
}

SetSettingStmt "set setting" <- "set " _ id:Identifier _ v:( "hex" / "dec" / "bin" ) {
  err := SetSetting(id.(string), string(v.([]byte)))
	return nil, err
}

SetStmt "set statement" <- _ id:Identifier _ '=' _ expr:Expr {
	node := &ast.SetStmt{Name: id.(string), Rhs: expr}
  ast.SetParent(expr, node)
	return node, nil
}

DefStmt "def statement" <- "def " name:Identifier _ '(' _ parms:DefStmtParms _ ')' _ help:( '"' DefHelp '"' )? _ expr:Expr {
	f, err := handleFuncDef(parms, help, expr)
	if err != nil {
		return nil, err
	}
	
	f.Name = name.(string)

	return f, nil
}

DefStmtParms "def stmt params" <- first:Identifier? rest:( _ ',' _ Identifier )* {
	l := buildSlice(first, rest, 3)
	return l, nil
}

DefHelp "def stmt help" <- [^"]+ {
	// "
  return string(c.text), nil
}

HelpStmt "help stmt" <- _ "help" _ {
  printFuncHelp() 
	return nil, nil
}

/* vim: set filetype=go :*/
