{
  // This is a Parsing Expression Grammar (PEG) for a simple calculator.
  // Generate the .go file with '$GOPATH/bin/pigeon $GOPATH/src/calc/calc.peg | $GOPATH/bin/goimports > $GOPATH/src/calc/peg.go'
  // This block is the initializer

  package main

  import (
    "math/big"
    "strings"
  )

	func toIfaceSlice(v interface{}) []interface{} {
		if v == nil {
			return nil
		}
		return v.([]interface{})
	}

	func toStringSlice(v []interface{}) []string {
    r := make([]string, len(v))
		for i,e := range v {
      r[i] = e.(string)
		}
		return r
	}

	func charClassRepetitionToByteSlice(x interface{}) []byte {
    buf := make([]byte,0,100)
    for _,v := range x.([]interface{}){
      buf = append(buf, v.([]byte)...)
	  }
		return buf
	}

	func charClassRepetitionToStr(x interface{}) string {
	  return string(charClassRepetitionToByteSlice(x))
	}


	// Evaluate the expression for a rule that consists of an operand, operator, 
	// and expression.
	func handleBinaryOpExpr(num, rest interface{}) (interface{}, error) {
		var err error

		acc := num
		for _, v := range toIfaceSlice(rest) {
			list := toIfaceSlice(v)

			// In the list item 0 is spaces, 1 is op, 2 is spaces, 3 is operand
			o := rune(list[1].([]uint8)[0])
			acc, err = evalBinaryOp(o, acc, list[3])
			if err != nil {
				return acc, err
			}
		}

		return acc, nil
	}	

	// Evaluate the expression for a rule that consists of an operator and operand.
	func handleUnaryOpExpr(op interface{}, num interface{}) (interface{}, error) {
		o := rune(op.([]uint8)[0])

		return evalUnaryOp(o, num)
	}	
}

Input "input" <- first:(Block?) rest:((';' Block)*) EOF {
  if rest == nil || len(rest.([]interface{})) == 0 {
    return first, nil
  } else {
    l := []interface{}{}
    if first != nil {
      l = append(l, first)
    }
  
    if rest != nil {
      for _,v := range rest.([]interface{}) {
        // Ignore semicolons
        l = append(l, v.([]interface{})[1])
      }
    }
  
    return l, nil
  }
}

Block <- n:(Stmt / Expr) {
  return n, nil
}

// This is just so that spurious carriage returns don't print errors.
Empty "empty line" <- _ {
	return "", nil
}

Expr "expression" <- _ n:(Prec2Expr / FuncCallOrParen) _ {
  return n, nil
}

Prec2Expr "precedence 2 expression" <- num:Prec1Expr rest:(_ Prec2Op _ Prec1Expr)*  {
	return handleBinaryOpExpr(num, rest)
}

Prec1Expr "precedence 1 expression" <- num:Prec0Expr rest:(_ Prec1Op _ Prec0Expr)*  {
	return handleBinaryOpExpr(num, rest)
}

Prec0Expr "precedence 0 expression" <- num:( UnaryExpr / Prec0OpExpr ) {
	return num, nil
}

UnaryExpr <- op:[~-] num:FuncCallOrParen {
	return handleUnaryOpExpr(op, num)
}

Prec0OpExpr "precedence 0 expression" <- num:FuncCallOrParen rest:(_ Prec0Op _ FuncCallOrParen)*  {
	return handleBinaryOpExpr(num, rest)
}

FuncCallOrParen "function call or expression in parenthesis" <- n:(Paren / FuncCall / Number / Variable ) {
	return n, nil
}

Paren "parenthesis expression" <- '(' e:Expr ')' {
  return e, nil
}

FuncCall "function call" <- name:Identifier _ '(' parms:FuncParms ')' {
	nm := name.(string)
	if parms == nil {
    parms = []interface{}{}
	}
  return Call(nm, parms.([]interface{}))
}

FuncParms "function params" <- first:Expr? rest:( ',' Expr )* {
	l := []interface{}{}
	if first != nil {
	  l = append(l, first)
	}

	if rest != nil {
	  for _,v := range rest.([]interface{}) {
		  // Ignore commas
		  l = append(l, v.([]interface{})[1])
	  }
	}

	return l, nil
}

Number "number" <- n:(Float / Int) {
  return n, nil
}

Float "float" <- [0-9]* '.' [0-9]+ {
  f := new(big.Float)
  _, err := fmt.Sscan(strings.Replace(string(c.text),",","",-1), f)
  return f, err
}

Int "int" <- ( ( "0x" [0-9a-zA-Z]+ ) / ( "0b" [01]+ ) / [0-9]+ ) {
  i := new(big.Int)
  _, err := fmt.Sscan(strings.Replace(string(c.text),",","",-1), i)
  return i, err
}

Variable <- id:Identifier {
   return Resolve(id.(string))
}

Identifier <- [a-zA-Z_] [a-zA-Z0-9_]* {
  return string(c.text), nil
}

Prec1Op <- '*' / '/' / '|'
Prec2Op <- '+' / '-' / '&'
Prec0Op <- '^' 

_ "spaces" <- [ \t]*

EOF <- !.

// Statements 
Stmt "statement" <- SetSettingStmt / SetStmt / DefStmt / HelpStmt {
	return nil, nil
}

SetSettingStmt "set setting" <- "set " _ id:Identifier _ v:( "hex" / "dec" / "bin" ) {
  err := SetSetting(id.(string), string(v.([]byte)))
	return nil, err
}

SetStmt "set statement" <- id:Identifier _ '=' _ expr:Expr {
  SetGlobal(id.(string), expr)
	return nil, nil
}

DefStmt "def statement" <- "def " name:Identifier _ '(' _ parms:DefStmtParms _ ')' _ help:( '"' DefHelp '"' )? _ expr:([^,]+) {
  
	buf := charClassRepetitionToByteSlice(expr)

  // first try parsing the function's body to see if it's valid.
  // since the body likely contains variables, we'll expect an 
	// unbound variable error but no other ones that indicate
	// a parse error.
	if err := validateFuncDef(parms.([]interface{}), buf); err != nil { 
	  return nil, err
	}

	nm := name.(string)
	var hlp string
	if help != nil {
	  hlp = help.([]interface{})[1].(string)
	}
	prm := toStringSlice(parms.([]interface{}))
  RegisterDefined(nm, prm, buf, hlp)
	return nil, nil
}

DefStmtParms "def stmt params" <- first:Identifier? rest:( _ ',' _ Identifier )* {
  
	l := []interface{}{}
	if first != nil && len(first.(string)) > 0 {
	  l = append(l, first)
	}

	for _,v := range rest.([]interface{}) {
		// Ignore commas
		l = append(l, v.([]interface{})[3])
	}

	return l, nil
}

DefHelp "def stmt help" <- [^"]+ {
	// "
  return string(c.text), nil
}

HelpStmt "help stmt" <- _ "help" _ {
  printFuncHelp() 
	return nil, nil
}

/* vim: set filetype=go :*/
