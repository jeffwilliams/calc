{
  // This is a Parsing Expression Grammar (PEG) for a simple calculator.
  // Generate the .go file with '$GOPATH/bin/pigeon $GOPATH/src/calc/calc.peg | $GOPATH/bin/goimports > $GOPATH/src/calc/peg.go'
  // This block is the initializer

  package main

  import (
    "math/big"
  )

	func toIfaceSlice(v interface{}) []interface{} {
		if v == nil {
			return nil
		}
		return v.([]interface{})
	}


	// Evaluate the expression for a rule that consists of an operand, operator, 
	// and expression.
	func handleBinaryOpExpr(num, rest interface{}) (interface{}, error) {
		var err error

		acc := num
		for _, v := range toIfaceSlice(rest) {
			list := toIfaceSlice(v)

			// In the list item 0 is spaces, 1 is op, 2 is spaces, 3 is operand
			o := rune(list[1].([]uint8)[0])
			acc, err = evalBinaryOp(o, acc, list[3])
			if err != nil {
				return acc, err
			}
		}

		return acc, nil
	}	

	// Evaluate the expression for a rule that consists of an operator and operand.
	func handleUnaryOpExpr(op interface{}, num interface{}) (interface{}, error) {
		o := rune(op.([]uint8)[0])

		return evalUnaryOp(o, num)
	}	
}

Input "input" <- n:(Expr / Stmt / Empty) EOF {
  return n, nil
}

// This is just so that spurious carriage returns don't print errors.
Empty "empty line" <- _ {
	return "", nil
}

Expr "expression" <- _ n:(Prec2Expr / Paren) _ {
  return n, nil
}

Prec2Expr "precedence 2 expression" <- num:Prec1Expr rest:(_ Prec2Op _ Prec1Expr)*  {
	return handleBinaryOpExpr(num, rest)
}

Prec1Expr "precedence 1 expression" <- num:Prec0Expr rest:(_ Prec1Op _ Prec0Expr)*  {
	return handleBinaryOpExpr(num, rest)
}

Prec0Expr "precedence 0 expression" <- num:( UnaryExpr / Prec0OpExpr ) {
	return num, nil
}

UnaryExpr <- op:[~-] num:Paren {
	return handleUnaryOpExpr(op, num)
}

Prec0OpExpr "precedence 0 expression" <- num:Paren rest:(_ Prec0Op _ Paren)*  {
	return handleBinaryOpExpr(num, rest)
}

Paren "parenthesis expression" <- '(' e:Expr ')' {
  return e, nil
} / n:Number {
  return n, nil
}

Number "number" <- n:(Float / Int) {
  return n, nil
}

Float "float" <- [0-9]* '.' [0-9]+ {
  f := new(big.Float)
  _, err := fmt.Sscan(string(c.text), f)
  return f, err
}

Int "int" <- ( ( "0x" [0-9a-zA-Z]+ ) / ( "0b" [01]+ ) / [0-9]+ ) {
  i := new(big.Int)
  _, err := fmt.Sscan(string(c.text), i)
  return i, err
}

Prec1Op <- '*' / '/' / '|'
Prec2Op <- '+' / '-' / '&'
Prec0Op <- '^' 

_ "spaces" <- [ \t]*

EOF <- !.

// Statements 
Stmt "statement" <- SetStmt {
	return nil, nil
}

SetStmt "set statement" <- "obase" _ '=' _ v:( "hex" / "dec" / "bin" ) {
	err := outputBase.Set(string(v.([]byte)))
	return nil, err
}



/* vim: set filetype=go :*/
