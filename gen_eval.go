// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package main

import (
	"fmt"
	"math/big"
)

func evalBinaryOpbigInt(op rune, a, b *big.Int) (r *big.Int, err error) {
	switch op {
	case '+':
		r = a.Add(a, b)
	case '-':
		r = a.Sub(a, b)
	case '*':
		r = a.Mul(a, b)
	case '/':
		r = a.Quo(a, b)
	default:
		err = fmt.Errorf("evalBinaryOpbigInt: Invalid operator %s", op)
	}
	return
}

func evalUnaryOpbigInt(op rune, a *big.Int) (r *big.Int, err error) {
	switch op {
	case '-':
		r = a.Neg(a)
	default:
		err = fmt.Errorf("evalUnaryOpbigInt: Invalid operator %s", op)
	}
	return
}

/* vim: set filetype=go :*/

func evalBinaryOpbigFloat(op rune, a, b *big.Float) (r *big.Float, err error) {
	switch op {
	case '+':
		r = a.Add(a, b)
	case '-':
		r = a.Sub(a, b)
	case '*':
		r = a.Mul(a, b)
	case '/':
		r = a.Quo(a, b)
	default:
		err = fmt.Errorf("evalBinaryOpbigFloat: Invalid operator %s", op)
	}
	return
}

func evalUnaryOpbigFloat(op rune, a *big.Float) (r *big.Float, err error) {
	switch op {
	case '-':
		r = a.Neg(a)
	default:
		err = fmt.Errorf("evalUnaryOpbigFloat: Invalid operator %s", op)
	}
	return
}

/* vim: set filetype=go :*/
